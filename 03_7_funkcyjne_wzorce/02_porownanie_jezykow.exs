# Porównanie składni: JavaScript, Ruby vs Elixir

IO.puts("=== Porównanie składni: JavaScript, Ruby vs Elixir ===\n")

# =============== ZMIENNE I PODSTAWOWE TYPY ===============
IO.puts("--- ZMIENNE I PODSTAWOWE TYPY ---")

IO.puts("\n# Przypisanie zmiennej")
IO.puts("JavaScript: const x = 10;")
IO.puts("Ruby:       x = 10")
IO.puts("Elixir:     x = 10  # ale jest to wiązanie, nie przypisanie!\n")

IO.puts("# Stałe")
IO.puts("JavaScript: const PI = 3.14;")
IO.puts("Ruby:       PI = 3.14")
IO.puts("Elixir:     @pi 3.14  # w module")
IO.puts("           lub")
IO.puts("           pi = 3.14  # immutability czyni wszystkie zmienne stałymi\n")

IO.puts("# Łańcuchy znaków - interpolacja")
IO.puts("JavaScript: `Suma: ${1 + 2}`")
IO.puts("Ruby:       \"Suma: #{1 + 2}\"")
IO.puts("Elixir:     \"Suma: #{1 + 2}\"\n")

IO.puts("# Listy/Tablice")
IO.puts("JavaScript: const lista = [1, 2, 3];")
IO.puts("Ruby:       lista = [1, 2, 3]")
IO.puts("Elixir:     lista = [1, 2, 3]\n")

IO.puts("# Obiekty/Hash/Mapy")
IO.puts("JavaScript: const osoba = { imie: 'Jan', wiek: 30 };")
IO.puts("Ruby:       osoba = { imie: 'Jan', wiek: 30 }")
IO.puts("Elixir:     osoba = %{imie: \"Jan\", wiek: 30}  # mapa z kluczami jako atomami")
IO.puts("           lub")
IO.puts("           osoba = %{\"imie\" => \"Jan\", \"wiek\" => 30}  # mapa z kluczami jako stringami\n")

# =============== FUNKCJE ===============
IO.puts("\n--- FUNKCJE ---")

IO.puts("\n# Definiowanie funkcji")
IO.puts("JavaScript: function dodaj(a, b) { return a + b; }")
IO.puts("           // lub")
IO.puts("           const dodaj = (a, b) => a + b;")
IO.puts("Ruby:       def dodaj(a, b)")
IO.puts("             a + b   # Ostatnie wyrażenie jest zwracane")
IO.puts("           end")
IO.puts("Elixir:     def dodaj(a, b), do: a + b")
IO.puts("           # lub")
IO.puts("           def dodaj(a, b) do")
IO.puts("             a + b")
IO.puts("           end\n")

IO.puts("# Funkcje anonimowe")
IO.puts("JavaScript: const kwadrat = x => x * x;")
IO.puts("Ruby:       kwadrat = ->(x) { x * x }")
IO.puts("Elixir:     kwadrat = fn x -> x * x end\n")

IO.puts("# Wywołanie funkcji anonimowej")
IO.puts("JavaScript: kwadrat(5);")
IO.puts("Ruby:       kwadrat.call(5)")
IO.puts("Elixir:     kwadrat.(5)  # zwróć uwagę na kropkę!\n")

# =============== INSTRUKCJE STERUJĄCE ===============
IO.puts("\n--- INSTRUKCJE STERUJĄCE ---")

IO.puts("\n# Instrukcja if")
IO.puts("JavaScript: if (x > 10) {")
IO.puts("             console.log('Większe');")
IO.puts("           } else {")
IO.puts("             console.log('Mniejsze lub równe');")
IO.puts("           }")
IO.puts("Ruby:       if x > 10")
IO.puts("             puts 'Większe'")
IO.puts("           else")
IO.puts("             puts 'Mniejsze lub równe'")
IO.puts("           end")
IO.puts("Elixir:     if x > 10 do")
IO.puts("             IO.puts \"Większe\"")
IO.puts("           else")
IO.puts("             IO.puts \"Mniejsze lub równe\"")
IO.puts("           end")
IO.puts("           # lub jako wyrażenie")
IO.puts("           komunikat = if x > 10, do: \"Większe\", else: \"Mniejsze lub równe\"\n")

IO.puts("# Case / Switch")
IO.puts("JavaScript: switch(status) {")
IO.puts("             case 'ok':")
IO.puts("               console.log('Wszystko ok');")
IO.puts("               break;")
IO.puts("             case 'error':")
IO.puts("               console.log('Błąd');")
IO.puts("               break;")
IO.puts("             default:")
IO.puts("               console.log('Nieznany status');")
IO.puts("           }")
IO.puts("Ruby:       case status")
IO.puts("           when 'ok'")
IO.puts("             puts 'Wszystko ok'")
IO.puts("           when 'error'")
IO.puts("             puts 'Błąd'")
IO.puts("           else")
IO.puts("             puts 'Nieznany status'")
IO.puts("           end")
IO.puts("Elixir:     case status do")
IO.puts("             \"ok\" -> IO.puts \"Wszystko ok\"")
IO.puts("             \"error\" -> IO.puts \"Błąd\"")
IO.puts("             _ -> IO.puts \"Nieznany status\"")
IO.puts("           end\n")

# =============== OPERACJE NA KOLEKCJACH ===============
IO.puts("\n--- OPERACJE NA KOLEKCJACH ---")

IO.puts("\n# Map - transformacja elementów kolekcji")
IO.puts("JavaScript: const podwojna = [1, 2, 3].map(x => x * 2);")
IO.puts("Ruby:       podwojna = [1, 2, 3].map { |x| x * 2 }")
IO.puts("Elixir:     podwojna = Enum.map([1, 2, 3], fn x -> x * 2 end)")
IO.puts("           # lub z pipe")
IO.puts("           podwojna = [1, 2, 3] |> Enum.map(fn x -> x * 2 end)")
IO.puts("           # lub z klauzulą capture")
IO.puts("           podwojna = [1, 2, 3] |> Enum.map(&(&1 * 2))\n")

IO.puts("# Filter - filtrowanie elementów")
IO.puts("JavaScript: const parzyste = [1, 2, 3, 4].filter(x => x % 2 === 0);")
IO.puts("Ruby:       parzyste = [1, 2, 3, 4].select { |x| x % 2 == 0 }")
IO.puts("Elixir:     parzyste = Enum.filter([1, 2, 3, 4], fn x -> rem(x, 2) == 0 end)")
IO.puts("           # lub")
IO.puts("           parzyste = [1, 2, 3, 4] |> Enum.filter(&(rem(&1, 2) == 0))\n")

IO.puts("# Reduce - agregacja elementów")
IO.puts("JavaScript: const suma = [1, 2, 3].reduce((acc, x) => acc + x, 0);")
IO.puts("Ruby:       suma = [1, 2, 3].reduce(0) { |acc, x| acc + x }")
IO.puts("Elixir:     suma = Enum.reduce([1, 2, 3], 0, fn x, acc -> acc + x end)")
IO.puts("           # lub")
IO.puts("           suma = [1, 2, 3] |> Enum.reduce(0, &(&1 + &2))\n")

# =============== STRUKTURY DANYCH ===============
IO.puts("\n--- STRUKTURY DANYCH ---")

IO.puts("\n# Dodawanie do listy/tablicy")
IO.puts("JavaScript: const nowaTablica = [...stara, nowyElement];  // immutable")
IO.puts("           lub stara.push(nowyElement);  // mutable")
IO.puts("Ruby:       nowa = stara + [nowy_element]  # immutable")
IO.puts("           lub stara << nowy_element  # mutable")
IO.puts("Elixir:     nowa = stara ++ [nowy_element]  # zawsze immutable!")
IO.puts("           lub [nowy_element | stara]  # dodanie na początek\n")

IO.puts("# Aktualizacja obiektu/mapy")
IO.puts("JavaScript: const nowaOsoba = {...osoba, wiek: 31};  // immutable")
IO.puts("           lub osoba.wiek = 31;  // mutable")
IO.puts("Ruby:       nowa_osoba = osoba.merge(wiek: 31)  # immutable")
IO.puts("           lub osoba[:wiek] = 31  # mutable")
IO.puts("Elixir:     nowa_osoba = %{osoba | wiek: 31}  # zawsze immutable!")
IO.puts("           # Uwaga: %{osoba | wiek: 31} działa tylko jeśli klucz już istnieje")
IO.puts("           nowa_osoba = Map.put(osoba, :wiek, 31)  # działa zawsze\n")

# =============== OBSŁUGA BŁĘDÓW ===============
IO.puts("\n--- OBSŁUGA BŁĘDÓW ---")

IO.puts("\n# Mechanizm try-catch")
IO.puts("JavaScript: try {")
IO.puts("             // ryzykowny kod")
IO.puts("           } catch(error) {")
IO.puts("             console.error(error);")
IO.puts("           }")
IO.puts("Ruby:       begin")
IO.puts("             # ryzykowny kod")
IO.puts("           rescue => e")
IO.puts("             puts e.message")
IO.puts("           end")
IO.puts("Elixir:     try do")
IO.puts("             # ryzykowny kod")
IO.puts("           rescue")
IO.puts("             e -> IO.puts e.message")
IO.puts("           end\n")

# =============== PATTERN MATCHING ===============
IO.puts("\n--- PATTERN MATCHING ---")

IO.puts("\nJavaScript i Ruby mają ograniczone możliwości pattern matchingu.")
IO.puts("Elixir oferuje zaawansowany pattern matching będący podstawą języka:\n")

IO.puts("# Podstawowy pattern matching")
IO.puts("JavaScript: const {imie, wiek} = osoba;  // destrukturyzacja obiektu")
IO.puts("Ruby:       imie, wiek = [\"Jan\", 30]   # przypisanie wielokrotne")
IO.puts("Elixir:     %{imie: imie, wiek: wiek} = osoba  # pattern matching")
IO.puts("           {imie, wiek} = {\"Jan\", 30}\n")

IO.puts("# Pattern matching w funkcjach")
IO.puts("JavaScript: // Brak natywnego wsparcia")
IO.puts("Ruby:       # Ograniczone wsparcie")
IO.puts("Elixir:")
IO.puts("           def powitaj(%{imie: imie, wiek: wiek}), do:")
IO.puts("             \"Cześć #{imie}, masz #{wiek} lat!\"")
IO.puts("           end")
IO.puts("\n           # Różne implementacje dla różnych wartości")
IO.puts("           def silnia(0), do: 1")
IO.puts("           def silnia(n) when n > 0, do: n * silnia(n-1)\n")

# =============== ASYNCHRONICZNOŚĆ ===============
IO.puts("\n--- ASYNCHRONICZNOŚĆ ---")

IO.puts("\n# Operacje asynchroniczne")
IO.puts("JavaScript: // Promisy")
IO.puts("           fetch('https://api.example.com/data')")
IO.puts("             .then(response => response.json())")
IO.puts("             .then(data => console.log(data))")
IO.puts("             .catch(error => console.error(error));")
IO.puts("           // lub async/await")
IO.puts("           async function pobierzDane() {")
IO.puts("             try {")
IO.puts("               const response = await fetch('https://api.example.com/data');")
IO.puts("               const data = await response.json();")
IO.puts("               console.log(data);")
IO.puts("             } catch (error) {")
IO.puts("               console.error(error);")
IO.puts("             }")
IO.puts("           }")
IO.puts("Ruby:       # Wątki")
IO.puts("           Thread.new do")
IO.puts("             # asynchroniczny kod")
IO.puts("           end")
IO.puts("Elixir:     # Procesy")
IO.puts("           spawn(fn -> ")
IO.puts("             # asynchroniczny kod")
IO.puts("           end)")
IO.puts("           # lub Task")
IO.puts("           Task.async(fn -> ")
IO.puts("             # kod")
IO.puts("           end) |> Task.await\n")

IO.puts("\nTe przykłady pokazują jedynie podstawowe różnice. ")
IO.puts("Elixir ma wiele unikalnych cech, które wynikają z jego")
IO.puts("funkcyjnej natury i działania na maszynie wirtualnej BEAM.")
